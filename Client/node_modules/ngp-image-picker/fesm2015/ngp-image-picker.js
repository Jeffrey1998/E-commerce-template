import { __awaiter } from 'tslib';
import { EventEmitter, Component, ViewEncapsulation, Input, ViewChild, Output, NgModule } from '@angular/core';
import { ResizeObserver } from 'resize-observer';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { CommonModule } from '@angular/common';
import { MatSliderModule } from '@angular/material/slider';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';

class NgpImagePickerComponent {
    constructor() {
        this.config = {
            height: '240px',
            width: '320px',
            borderRadius: '16px',
            compressInitial: true,
            language: 'en',
            hideDeleteBtn: false,
            hideDownloadBtn: false,
            hideEditBtn: false,
            hideAddBtn: false,
        };
        this.observer = null;
        this.showCrop = false;
        this.loadImage = false;
        this.uuidFilePicker = Date.now().toString(20);
        this.showEditPanel = false;
        this.quality = 92;
        this.format = 'jpeg';
        this.allFormats = ['webp', 'jpeg', 'png'];
        this.maxHeight = 2000;
        this.maxWidth = 2000;
        this.cropHeight = 150;
        this.cropWidth = 150;
        this.maintainAspectRatio = true;
        this.imageName = 'donload';
        ///////////////////////////////////////////////////////
        this.labelEn = {
            'Upload a image': 'Upload a image',
            'You must edit the image in order to resize it': 'You must edit the image in order to resize it',
            'too large': 'too large',
            'Open the editor panel': 'Open the editor panel',
            'Download the image': 'Download the image',
            'Control Panel': 'Control Panel',
            Quality: 'Quality',
            'Max dimensions': 'Max dimensions',
            'aspect-ratio': 'aspect-ratio',
            'max-width(px)': 'max-width(px)',
            'max-height(px)': 'max-height(px)',
            Format: 'Format',
            Crop: 'Crop',
            'width(px)': 'width(px)',
            'height(px)': 'height(px)',
            'Remove': 'Remove',
        };
        this.labelEs = {
            'Upload a image': 'Suba una imagen',
            'You must edit the image in order to resize it': 'Debe editar la imagen para disminuir su tamaño',
            'too large': 'muy grande',
            'Open the editor panel': 'Abra el panel de edición',
            'Download the image': 'Descarge la imagen',
            'Control Panel': 'Panel de control',
            'Remove': 'Quitar',
            Quality: 'Calidad',
            'Max dimensions': 'Dimensiones',
            'aspect-ratio': 'relación-aspecto',
            'max-width(px)': 'max. ancho',
            'max-height(px)': 'max. alto',
            Format: 'Formato',
            Crop: 'Recortar',
            'width(px)': 'ancho(px)',
            'height(px)': 'altura(px)',
        };
        this.labels = this.labelEn;
        this.arrayCopiedImages = [];
        this.$imageChanged = new EventEmitter();
        this.$imageOriginal = new EventEmitter();
    }
    set _imageSrc(value) {
        if (value != undefined) {
            this.parseToBase64(value).then((dataUri) => {
                this.imageSrc = dataUri;
                this.arrayCopiedImages = [];
                this.arrayCopiedImages.push(this.imageSrc);
                this.originImageSrc = value;
                this.lastOriginSrc = value;
                this.$imageOriginal.next(this.originImageSrc);
                this.loadImage = true;
            });
        }
        else {
            this.imageSrc = null;
            this.originImageSrc = null;
            this.loadImage = false;
            this.arrayCopiedImages = [];
            this.lastOriginSrc = null;
            this.$imageOriginal.next(null);
            this.format = 'jpeg';
            this.maxHeight = 2000;
            this.maxWidth = 2000;
            this.cropHeight = 150;
            this.cropWidth = 150;
            this.maintainAspectRatio = true;
            this.showEditPanel = false;
        }
    }
    set _config(value) {
        this.processConfig(value);
    }
    ngOnInit() { }
    onUpload(event) {
        event.preventDefault();
        // const element: HTMLElement = document.getElementById('filePicker-' + this.uuidFilePicker) as HTMLElement;
        this.imagePicker.nativeElement.click();
        // element.click();
    }
    handleFileSelect(evt) {
        var _a;
        const files = (_a = evt.target) === null || _a === void 0 ? void 0 : _a.files;
        if (files) {
            const file = files[0];
            this.imageName = file.name.split('.')[0];
            // console.log('NgpImagePickerComponent -> handleFileSelect -> file.name', file.name);
            this.fileType = file.type;
            this.urlImage = `data:${file.type};base64,`;
            if (files && file) {
                const reader = new FileReader();
                reader.onload = this.handleReaderLoaded.bind(this);
                reader.readAsBinaryString(file);
            }
        }
    }
    handleReaderLoaded(readerEvt) {
        return __awaiter(this, void 0, void 0, function* () {
            const binaryString = readerEvt.target.result;
            const base64textString = btoa(binaryString);
            this.originImageSrc = this.urlImage + base64textString;
            this.lastOriginSrc = this.urlImage + base64textString;
            if (this.config.compressInitial) {
                this.quality = 92;
                const input = {
                    dataType: this.format,
                    quality: 0.92,
                    maintainRatio: true,
                };
                this.imageSrc = yield this.resizedataURL(this.urlImage + base64textString, input);
            }
            else {
                this.imageSrc = this.urlImage + base64textString;
                this.arrayCopiedImages = [];
                this.arrayCopiedImages.push({
                    lastImage: this.imageSrc,
                    width: this.maxWidth,
                    height: this.maxHeight,
                    quality: this.quality,
                });
                this.$imageOriginal.next(this.imageSrc);
            }
            this.$imageChanged.next(this.imageSrc);
            this.loadImage = true;
        });
    }
    onOpenEditPanel() {
        this.showEditPanel = true;
    }
    onCloseEditPanel() {
        if (this.observer instanceof ResizeObserver) {
            this.observer.unobserve(document.getElementById('image-croper'));
            this.observer.unobserve(document.getElementById('image-full'));
        }
        this.showCrop = false;
        this.showEditPanel = false;
    }
    parseToBase64(imageUrl) {
        let types = imageUrl.split('.');
        let type = types[types.length - 1];
        // console.log('ImagePickerComponent -> ngOnInit -> type', type);
        if (type && (type == 'png' || type == 'jpeg' || type == 'webp')) {
            type = type;
        }
        else {
            type = 'jpeg';
        }
        this.format = type;
        return new Promise((resolve, reject) => {
            let img = document.createElement('img');
            img.crossOrigin = 'Anonymous';
            img.src = imageUrl;
            this.maxHeight = img.height;
            this.maxWidth = img.width;
            img.onload = function () {
                let canvas = document.createElement('canvas');
                let ctx = canvas.getContext('2d');
                let ratio = 1.0;
                canvas.width = img.width * ratio;
                canvas.height = img.height * ratio;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                let dataURI = canvas.toDataURL(`image/${type}`, 0.92);
                return resolve({
                    dataUri: dataURI,
                    width: canvas.width,
                    height: canvas.height,
                });
            };
        }).then((data) => {
            // console.log('ImagePickerComponent -> ngOnInit -> data', data);
            this.maxHeight = data.height;
            this.maxWidth = data.width;
            return data.dataUri;
        });
    }
    processConfig(value) {
        if (value && value.constructor == Object) {
            this.config = Object.assign(Object.assign({}, this.config), value);
            if (value.language != undefined) {
                if (value.language == 'en') {
                    this.labels = Object.assign({}, this.labelEn);
                }
                if (value.language == 'es') {
                    this.labels = Object.assign({}, this.labelEs);
                }
            }
        }
    }
    /////////////////////////////////////////////////
    resizedataURL(datas, input) {
        return new Promise(function (resolve, reject) {
            return __awaiter(this, void 0, void 0, function* () {
                let img = document.createElement('img');
                img.src = datas + '';
                img.crossOrigin = 'Anonymous';
                let quality = input.quality ? input.quality : 1.0;
                let maintainRatio = input.maintainRatio != undefined ? input.maintainRatio : true;
                img.onload = function () {
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext('2d');
                    let ratio = img.width / img.height;
                    let width = input.width ? input.width : img.width;
                    let height = input.height ? input.height : img.height;
                    if (maintainRatio) {
                        if (input.changeHeight) {
                            canvas.width = height * ratio;
                            canvas.height = height;
                        }
                        else {
                            canvas.width = width;
                            canvas.height = width / ratio;
                        }
                    }
                    else {
                        canvas.width = width;
                        canvas.height = height;
                    }
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    let type = input.dataType ? input.dataType : 'webp';
                    var dataURI = canvas.toDataURL(`image/${type}`, quality);
                    resolve({
                        dataUri: dataURI,
                        width: canvas.width,
                        height: canvas.height,
                    });
                };
            });
        }).then((data) => {
            // console.log('ImagePickerComponent -> ngOnInit -> data', data);
            this.maxHeight = data.height;
            this.maxWidth = data.width;
            if (this.arrayCopiedImages.length <= 20) {
                this.arrayCopiedImages.push({
                    lastImage: data.dataUri,
                    width: this.maxWidth,
                    height: this.maxHeight,
                    quality: this.quality,
                });
            }
            return data.dataUri;
        });
    }
    calculateSize() {
        let base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
        if (this.imageSrc && base64regex.test(this.imageSrc.split(',')[1])) {
            return Math.ceil(((3 / 4) * this.imageSrc.length) / 1024);
        }
        else {
            return;
        }
    }
    onChangeQuality(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const qualityItem = this.quality / 100;
            this.maxHeight = this.maxHeight && +this.maxHeight ? this.maxHeight : 2000;
            // console.log('ImagePickerComponent -> onChangeQuality -> this.maxHeight', this.maxHeight);
            this.maxWidth = this.maxWidth && +this.maxWidth ? this.maxWidth : 2000;
            // console.log('ImagePickerComponent -> onChangeQuality ->  this.maxWidth', this.maxWidth);
            yield this.wait(250);
            try {
                const input = {
                    height: this.maxHeight,
                    width: this.maxWidth,
                    dataType: this.format,
                    quality: qualityItem,
                    maintainRatio: this.maintainAspectRatio,
                };
                this.imageSrc = yield this.resizedataURL(this.originImageSrc, input);
                this.$imageChanged.next(this.imageSrc);
                this.loadImage = true;
            }
            catch (error) {
                this.loadImage = true;
            }
        });
    }
    onChangeFormat(format) {
        return __awaiter(this, void 0, void 0, function* () {
            let qualityItem = this.quality / 100;
            this.maxHeight = this.maxHeight && +this.maxHeight ? this.maxHeight : 2000;
            this.maxWidth = this.maxWidth && +this.maxWidth ? this.maxWidth : 2000;
            // console.log('ImagePickerComponent -> onChangeFormat -> this.maintainAspectRatio', this.maintainAspectRatio);
            yield this.wait(250);
            try {
                let input = {
                    height: this.maxHeight,
                    width: this.maxWidth,
                    dataType: this.format,
                    quality: qualityItem,
                    maintainRatio: this.maintainAspectRatio,
                };
                this.imageSrc = yield this.resizedataURL(this.originImageSrc, input);
                this.$imageChanged.next(this.imageSrc);
                this.loadImage = true;
            }
            catch (error) {
                this.loadImage = true;
            }
        });
    }
    onChangeSize(changeWidth, changeHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            let qualityItem = this.quality / 100;
            this.maxHeight = this.maxHeight && +this.maxHeight ? this.maxHeight : 2000;
            this.maxWidth = this.maxWidth && +this.maxWidth ? this.maxWidth : 2000;
            yield this.wait(500);
            try {
                let input = {
                    height: this.maxHeight,
                    width: this.maxWidth,
                    dataType: this.format,
                    quality: qualityItem,
                    maintainRatio: this.maintainAspectRatio,
                    changeHeight: changeHeight,
                    changeWidth: changeWidth,
                };
                this.imageSrc = yield this.resizedataURL(this.originImageSrc, input);
                this.$imageChanged.next(this.imageSrc);
                this.loadImage = true;
            }
            catch (error) {
                this.loadImage = true;
            }
        });
    }
    onChangeCrop(data) {
        const croper = document.getElementById('image-croper');
        croper.style.width = this.cropWidth + 'px';
        croper.style.height = this.cropHeight + 'px';
    }
    ////////////////////////////////////////////////
    wait(ms) {
        ms = ms ? ms : 1000;
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                return resolve(true);
            }, ms);
        });
    }
    dragElement(elemnt) {
        var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        if (document.getElementById(elemnt.id + '-header')) {
            /* if present, the header is where you move the DIV from:*/
            document.getElementById(elemnt.id + '-header').onmousedown = dragMouseDown;
            document.getElementById(elemnt.id + '-header').ontouchstart = dragMouseDown;
        }
        else {
            /* otherwise, move the DIV from anywhere inside the DIV:*/
            elemnt.onmousedown = dragMouseDown;
            elemnt.ontouchstart = dragMouseDown;
        }
        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.ontouchend = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
            document.ontouchmove = elementDrag;
        }
        function elementDrag(e) {
            let holderImage = document.getElementById('image-full');
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            const newTop = elemnt.offsetTop - pos2;
            const newLeft = elemnt.offsetLeft - pos1;
            const rectHolder = holderImage.getBoundingClientRect();
            const rectElemnt = elemnt.getBoundingClientRect();
            if (newTop >= rectHolder.y + 8) {
                elemnt.style.top =
                    Math.min(newTop, rectHolder.y + rectHolder.height - rectElemnt.height - 4) + 'px';
            }
            if (newLeft > rectHolder.x + 4 &&
                rectHolder.x + rectHolder.width > rectElemnt.x + rectElemnt.width + 2) {
                elemnt.style.left =
                    Math.min(newLeft, rectHolder.x + rectHolder.width - rectElemnt.width - 4) + 'px';
            }
        }
        function closeDragElement() {
            /* stop moving when mouse button is released:*/
            document.onmouseup = null;
            document.onmousemove = null;
            document.ontouchend = null;
            document.ontouchmove = null;
        }
    }
    onCropStateChange() {
        const croper = document.getElementById('image-croper');
        if (this.showCrop) {
            croper.style.opacity = '1.0';
            this.dragElement(croper);
            this.observer = new ResizeObserver((entries) => {
                entries.forEach((entry) => {
                    if (this.showEditPanel) {
                        const elemntCropper = document.getElementById('image-croper');
                        const rectHolder = document
                            .getElementById('image-full')
                            .getBoundingClientRect();
                        const rectElemnt = elemntCropper.getBoundingClientRect();
                        const maxWidth = rectHolder.x + rectHolder.width - rectElemnt.x - 4;
                        const maxHeight = rectHolder.y + rectHolder.height - rectElemnt.y - 4;
                        elemntCropper.style.maxWidth = maxWidth + 'px';
                        elemntCropper.style.maxHeight = maxHeight + 'px';
                        this.cropWidth = rectElemnt.width;
                        this.cropHeight = rectElemnt.height;
                        if (entry.target.id == 'image-full') {
                            if (rectHolder.top > 0) {
                                elemntCropper.style.top = rectHolder.top + 4 + 'px';
                            }
                            elemntCropper.style.left = rectHolder.left + 4 + 'px';
                        }
                    }
                });
            });
            this.observer.observe(document.getElementById('image-croper'));
            this.observer.observe(document.getElementById('image-full'));
        }
        else {
            croper.style.opacity = '0.0';
            if (this.observer instanceof ResizeObserver) {
                this.observer.unobserve(document.getElementById('image-croper'));
                this.observer.unobserve(document.getElementById('image-full'));
            }
        }
    }
    onCrop(type) {
        type = type ? type : this.format;
        const croper = document.getElementById('image-croper');
        const rectCroper = croper.getBoundingClientRect();
        const dataHolderRect = document
            .getElementById('image-full')
            .getBoundingClientRect();
        const canvas = document.createElement('canvas');
        new Promise((resolve, reject) => {
            let ctx = canvas.getContext('2d');
            let img = document.getElementById('image-full');
            let image = new Image();
            image.src = this.imageSrc;
            image.onload = () => {
                let ratio = image.height / dataHolderRect.height;
                let newWidth = rectCroper.width * ratio;
                let newHeight = rectCroper.height * ratio;
                canvas.height = newHeight;
                canvas.width = newWidth;
                ctx.drawImage(image, Math.abs(rectCroper.x * ratio) - Math.abs(dataHolderRect.x * ratio), Math.abs(rectCroper.y * ratio) - Math.abs(dataHolderRect.y * ratio), newWidth, newHeight, 0, 0, newWidth, newHeight);
                // ctx.drawImage(image, 90, 130, 50, 60, 10, 10, 50, 60);
                resolve(canvas.toDataURL(`image/${type}`, 0.98));
            };
            image.onerror = (e) => {
                reject(e);
            };
        })
            .then((dataUri) => {
            // console.log('NgpImagePickerComponent -> onCrop -> dataUri', dataUri);
            this.imageSrc = dataUri;
            this.showCrop = false;
            this.onCropStateChange();
            this.maxWidth = canvas.width;
            this.maxHeight = canvas.height;
            this.lastOriginSrc = this.originImageSrc + '';
            this.originImageSrc = dataUri;
            this.$imageChanged.next(this.imageSrc);
        })
            .catch((e) => {
            console.log(e);
        });
    }
    onRestore() {
        if (this.arrayCopiedImages.length) {
            let lastState = this.arrayCopiedImages.pop();
            this.imageSrc = lastState.lastImage;
            this.maxWidth = lastState.width;
            this.maxHeight = lastState.height;
            this.originImageSrc = this.lastOriginSrc + '';
        }
        else {
            this.imageSrc = this.lastOriginSrc;
            this.originImageSrc = this.lastOriginSrc + '';
        }
        this.$imageChanged.next(this.imageSrc);
    }
    onRemove() {
        this.imageSrc = null;
        this.originImageSrc = null;
        this.loadImage = false;
        this.arrayCopiedImages = [];
        this.lastOriginSrc = null;
        this.$imageOriginal.next(null);
        this.$imageChanged.next(null);
        this.format = 'jpeg';
        this.maxHeight = 2000;
        this.maxWidth = 2000;
        this.cropHeight = 150;
        this.cropWidth = 150;
        this.maintainAspectRatio = true;
        this.showEditPanel = false;
    }
}
NgpImagePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngp-image-picker',
                template: "<div *ngIf=\"!loadImage\" class=\"place-image\">\n  <div class=\"image-holder\" [ngStyle]=\"{\n      width: this.config.width,\n      height: this.config.height,\n      borderRadius: this.config.borderRadius\n    }\">\n    <button matTooltip=\"{{ labels['Upload a image'] }}\" class=\"image-upload-btn\" mat-icon-button\n      (click)=\"onUpload($event)\">\n      <mat-icon class=\"mat-18\">add_a_photo</mat-icon>\n    </button>\n\n    <input #imagePicker type=\"file\" style=\"display: none\" [id]=\"'filePicker-' + this.uuidFilePicker\"\n      (change)=\"handleFileSelect($event)\" />\n  </div>\n</div>\n<div *ngIf=\"loadImage\" class=\"place-image\">\n  <div class=\"image-holder-loaded\" [ngStyle]=\"{\n      width: this.config.width,\n      height: this.config.height,\n      borderRadius: this.config.borderRadius\n    }\">\n    <img [src]=\"this.imageSrc\" alt=\"image-loaded\" [ngStyle]=\"{ borderRadius: this.config.borderRadius }\" />\n    <input #imagePicker type=\"file\" style=\"display: none\" [id]=\"'filePicker-' + this.uuidFilePicker\"\n      (change)=\"handleFileSelect($event)\" />\n  </div>\n  <p *ngIf=\"this.calculateSize()\" class=\"mat-caption image-caption\" [ngStyle]=\"{\n      color: this.calculateSize() > 120 ? '#f44336' : 'unset',\n      fontWeight: this.calculateSize() > 120 ? '500' : 'unset'\n    }\">\n    size: {{ this.calculateSize() }}Kb &nbsp; {{ this.format }}\n  </p>\n\n  <div\n    style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\"\n    class=\"editing-bar-btn\">\n    <button *ngIf=\"!this.config.hideAddBtn\" mat-icon-button matTooltip=\"{{ labels['Upload a image'] }}\" (click)=\"onUpload($event)\">\n      <mat-icon class=\"mat-18\">add_a_photo</mat-icon>\n    </button>\n    <button *ngIf=\"!this.config.hideEditBtn\" mat-icon-button matTooltip=\"{{ labels['Open the editor panel'] }}\" (click)=\"onOpenEditPanel()\">\n      <mat-icon class=\"mat-18\">edit</mat-icon>\n    </button>\n    <a *ngIf=\"!this.config.hideDownloadBtn\" matTooltip=\"{{ labels['Download the image'] }}\" [href]=\"this.imageSrc\" mat-icon-button\n      download=\"{{ imageName }}\">\n      <mat-icon class=\"mat-18\">cloud_download</mat-icon>\n    </a>\n    <button *ngIf=\"!this.config.hideDeleteBtn\" mat-icon-button  matTooltip=\"{{ labels['Remove'] }}\" (click)=\"onRemove()\">\n      <mat-icon class=\"mat-18\">delete</mat-icon>\n    </button>\n  </div>\n</div>\n\n<div *ngIf=\"showEditPanel\" id=\"popup\" class=\"popup\">\n  <div\n    style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: center flex-end; align-items: center\">\n    <button mat-icon-button (click)=\"onCloseEditPanel()\">\n      <mat-icon class=\"mat-18\">clear</mat-icon>\n    </button>\n  </div>\n\n  <div class=\"image-container\">\n    <div class=\"image-holder-full\">\n      <img id=\"image-full\" [src]=\"this.imageSrc\" />\n\n      <div id=\"image-croper\" class=\"image-croper\">\n        <div id=\"image-croper-header\">\n          <mat-icon>drag_indicator</mat-icon>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"control-panel\">\n      <p class=\"title-panel\">{{ labels['Control Panel'] }}</p>\n\n      <p class=\"item-panel\">{{ labels['Quality'] }}</p>\n      <div\n        style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n        <mat-slider color=\"primary\" style=\"max-width: 100%; width: 100%\" (change)=\"onChangeQuality($event.value)\"\n          [(ngModel)]=\"quality\" [min]=\"0\" [max]=\"100\" [step]=\"1\" [thumbLabel]=\"true\">\n        </mat-slider>\n      </div>\n\n      <p class=\"item-panel\">\n        {{ labels['Max dimensions'] }}\n        <mat-checkbox style=\"float: right\" [(ngModel)]=\"maintainAspectRatio\" color=\"primary\">\n          <span class=\"mat-caption\">{{ labels['aspect-ratio'] }}</span>\n        </mat-checkbox>\n      </p>\n      <div\n        style=\"margin-top: 8px !important; flex-flow: row wrap; box-sizing: border-box; display: flex; place-content: flex-start space-between; align-items: flex-start\">\n        <mat-form-field class=\"no-input-style\" style=\"max-width: 48%; width: 48%\" appearance=\"fill\">\n          <mat-label>{{ labels['max-width(px)'] }}</mat-label>\n          <input (change)=\"onChangeSize(true, false)\" matInput placeholder=\"{{ labels['max-width(px)'] }}\"\n            [(ngModel)]=\"maxWidth\" type=\"number\" [min]=\"0\" [max]=\"2000\" />\n        </mat-form-field>\n\n        <mat-form-field class=\"no-input-style\" style=\"max-width: 48%; width: 48%\" appearance=\"fill\">\n          <mat-label>{{ labels['max-height(px)'] }}</mat-label>\n          <input (change)=\"onChangeSize(false, true)\" matInput placeholder=\"{{ labels['max-height(px)'] }}\"\n            [(ngModel)]=\"maxHeight\" type=\"number\" [min]=\"0\" [max]=\"2000\" />\n        </mat-form-field>\n      </div>\n\n      <p class=\"item-panel\">{{ labels['Format'] }}</p>\n      <div\n        style=\"margin-top: 8px !important; flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n        <mat-form-field class=\"no-input-style\" style=\"max-width: 100%; width: 100%\" appearance=\"fill\" color=\"primary\">\n          <mat-select [(ngModel)]=\"format\" (selectionChange)=\"onChangeFormat($event.value)\">\n            <mat-option *ngFor=\"let format of allFormats\" [value]=\"format\">\n              {{ format }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n\n      <p>\n        <mat-checkbox (change)=\"onCropStateChange()\" [(ngModel)]=\"showCrop\" color=\"primary\">\n          <p class=\"item-panel\">{{ labels['Crop'] }}</p>\n        </mat-checkbox>\n        <button style=\"float: right\" mat-icon-button color=\"primary\" (click)=\"onRestore()\">\n          <mat-icon> refresh </mat-icon>\n        </button>\n      </p>\n\n      <ng-container *ngIf=\"showCrop\">\n        <div\n          style=\"margin-top: 8px !important; flex-flow: row wrap; box-sizing: border-box; display: flex; place-content: flex-start space-between; align-items: flex-start\">\n          <mat-form-field class=\"no-input-style\" style=\"max-width: 48%; width: 48%\" appearance=\"fill\">\n            <mat-label>{{ labels['width(px)'] }}</mat-label>\n            <input (change)=\"onChangeCrop($event.target.valueAsNumber)\" matInput placeholder=\"{{ labels['width(px)'] }}\"\n              [(ngModel)]=\"cropWidth\" type=\"number\" [min]=\"0\" [max]=\"2000\" />\n          </mat-form-field>\n          <mat-form-field class=\"no-input-style\" style=\"max-width: 48%; width: 48%\" appearance=\"fill\">\n            <mat-label>{{ labels['height(px)'] }}</mat-label>\n            <input (change)=\"onChangeCrop($event.target.valueAsNumber)\" matInput\n              placeholder=\"{{ labels['height(px)'] }}\" [(ngModel)]=\"cropHeight\" type=\"number\" [min]=\"0\" [max]=\"2000\" />\n          </mat-form-field>\n        </div>\n\n        <p style=\"margin-bottom: 4px !important\">\n          <button mat-icon-button color=\"primary\" (click)=\"onCrop()\">\n            <mat-icon> crop </mat-icon>\n          </button>\n        </p>\n      </ng-container>\n\n      <div\n        style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: center space-between; align-items: center\">\n        <button style=\"padding: 0px 8px; height: 34px; box-sizing: border-box; background-color: #fff; color: black\"\n          mat-flat-button (click)=\"onCloseEditPanel()\">Guardar</button>\n\n        <p *ngIf=\"this.calculateSize()\" class=\"mat-caption image-caption\" [ngStyle]=\"{\n            color: this.calculateSize() > 120 ? '#f44336' : 'unset',\n            fontWeight: this.calculateSize() > 120 ? '500' : 'unset'\n          }\">\n          size: {{ this.calculateSize() }}Kb &nbsp; {{ this.format }}\n        </p>\n      </div>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: ["ngp-image-picker p{margin:0!important;padding:0!important}ngp-image-picker .place-image{align-items:flex-start;box-sizing:border-box;display:flex;flex-direction:column;place-content:flex-start}ngp-image-picker .place-image .image-holder{align-items:center;background-color:#fcfcfc;border:2px solid rgba(0,0,0,.3);border-radius:16px;box-sizing:border-box;display:flex;flex-direction:column;height:240px;max-width:100%!important;place-content:center;position:relative;width:320px}@media (max-width:599px){ngp-image-picker .place-image .image-holder{max-height:250px!important;max-width:100%!important}}ngp-image-picker .place-image .image-holder .image-upload-btn{color:#424242;height:50px;opacity:.85;position:relative;transition:all .5s ease;width:50px}ngp-image-picker .place-image .image-holder .image-upload-btn mat-icon{color:#424242;font-size:50px;height:50px;line-height:50px;width:50px}@media (max-width:599px){ngp-image-picker .place-image .image-holder .image-upload-btn{height:30px;opacity:1;width:30px}ngp-image-picker .place-image .image-holder .image-upload-btn mat-icon{font-size:30px;height:30px;line-height:30px;width:30px}}ngp-image-picker .place-image .image-holder:hover .image-upload-btn{opacity:1;transition:all .5s ease}ngp-image-picker .place-image .image-holder-loaded{align-items:center;border-radius:4px;box-sizing:border-box;display:flex;flex-direction:column;height:240px;max-width:100%!important;padding:2px;place-content:center;position:relative;width:320px}ngp-image-picker .place-image .image-holder-loaded .image-caption{bottom:-22px;position:absolute;right:0}ngp-image-picker .place-image .image-holder-loaded img{-o-object-fit:cover;-o-object-position:center;height:100%;max-height:100%;max-width:100%;object-fit:cover;object-position:center;width:100%}@media (max-width:599px){ngp-image-picker .place-image .image-holder-loaded{max-height:195px!important}}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn{color:#424242;height:50px;opacity:.85;position:relative;transition:all .5s ease;width:50px}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn mat-icon{color:#424242;font-size:50px;height:50px;line-height:50px;width:50px}@media (max-width:599px){ngp-image-picker .place-image .image-holder-loaded .image-upload-btn{height:30px;opacity:1;width:30px}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn mat-icon{font-size:30px;height:30px;line-height:30px;width:30px}}ngp-image-picker .place-image .image-holder-loaded:hover .image-upload-btn{opacity:1;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn{margin-top:2px}ngp-image-picker .place-image .editing-bar-btn .mat-icon-button{height:20px;line-height:20px;width:24px}ngp-image-picker .place-image .editing-bar-btn mat-icon{font-size:20px!important;height:20px!important;line-height:20px!important;width:20px!important}ngp-image-picker .place-image .editing-bar-btn button{color:#424242;margin:4px;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn button:hover{margin:4px 8px;transform:scale(1.25);transition:all .25s ease-in}ngp-image-picker .place-image .editing-bar-btn a{color:#424242;margin:4px;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn a:hover{margin:4px 8px;transform:scale(1.25);transition:all .25s ease-in}ngp-image-picker .popup{-webkit-animation-duration:.4s;-webkit-animation-name:show;animation-duration:.4s;animation-name:show;background-color:rgba(0,0,0,.8);box-sizing:border-box;color:#fff;height:100%;left:0;max-height:100%;overflow:auto;padding:24px;position:fixed;top:0;width:100vw;z-index:1000}ngp-image-picker .popup .image-container{align-items:flex-start;box-sizing:border-box;display:flex;flex-flow:row wrap;height:100%;margin-bottom:50px;margin-top:50px;min-height:100%;min-width:100%;place-content:flex-start center;width:100%}ngp-image-picker .popup .image-container .image-holder-full{display:contents;height:auto;position:relative;width:auto}ngp-image-picker .popup mat-icon{color:#fff}ngp-image-picker .popup img{-o-object-fit:cover;-o-object-position:center;margin:8px;max-height:600px;max-width:100%;object-fit:cover;object-position:center;transition:all .5s ease}@media (max-width:1024px){ngp-image-picker .popup{background-color:rgba(0,0,0,.85);padding:8px}ngp-image-picker .popup img{max-height:100%;max-width:100%}}@media (max-width:599px){ngp-image-picker .popup img{margin:0}}ngp-image-picker .popup .control-panel{align-items:stretch;background-color:rgba(0,0,0,.92);border-radius:8px;box-sizing:border-box;color:#fff;display:flex;flex-direction:column;margin:8px;max-width:100%;padding:16px;place-content:stretch flex-start;width:18rem}@media (max-width:599px){ngp-image-picker .popup .control-panel{margin:8px 0;width:100%}}ngp-image-picker .popup .control-panel .title-panel{font-size:17px;font-weight:500;margin-bottom:16px!important;padding:0 4px}ngp-image-picker .popup .control-panel .item-panel{font-size:14px;font-weight:500;padding:0 4px}@-webkit-keyframes show{0%{opacity:0;top:-100vh}to{opacity:1;top:0}}@keyframes show{0%{opacity:0;top:-100vh}to{opacity:1;top:0}}ngp-image-picker .mat-form-field-appearance-fill .mat-form-field-flex{background-color:#fafafa!important}ngp-image-picker .mat-select-panel{background:#fafafa!important}ngp-image-picker input.mat-input-element{color:rgba(0,0,0,.85)}ngp-image-picker .mat-checkbox-background{background-color:#fff}ngp-image-picker .image-croper{border:2.5px solid #fafafa;box-sizing:border-box;height:150px;opacity:0;overflow:auto;position:absolute;resize:both;width:150px}ngp-image-picker .image-croper #image-croper-header{background-color:transparent;color:#fff;cursor:move;height:85%;padding:10px;z-index:10}ngp-image-picker .image-croper #image-croper-header mat-icon{color:#fff}ngp-image-picker .btn{border-radius:4px;cursor:pointer;padding:4px 8px}ngp-image-picker .btn mat-icon{color:rgba(0,0,0,.82)}"]
            },] }
];
NgpImagePickerComponent.ctorParameters = () => [];
NgpImagePickerComponent.propDecorators = {
    _imageSrc: [{ type: Input }],
    _config: [{ type: Input }],
    imagePicker: [{ type: ViewChild, args: ['imagePicker', { static: false },] }],
    $imageChanged: [{ type: Output }],
    $imageOriginal: [{ type: Output }]
};

class NgpImagePickerModule {
}
NgpImagePickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgpImagePickerComponent],
                imports: [
                    CommonModule,
                    MatIconModule,
                    MatButtonModule,
                    MatTooltipModule,
                    MatSliderModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MatFormFieldModule,
                    MatSelectModule,
                    MatInputModule,
                    MatCheckboxModule,
                ],
                exports: [NgpImagePickerComponent],
            },] }
];

/*
 * Public API Surface of ngp-image-picker
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgpImagePickerComponent, NgpImagePickerModule };
//# sourceMappingURL=ngp-image-picker.js.map
